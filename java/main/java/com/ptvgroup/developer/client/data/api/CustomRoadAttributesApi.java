/*
 * Data
 * With the Data service you can obtain additional data such as vehicle profiles.
 *
 * The version of the OpenAPI document: 1.17
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.ptvgroup.developer.client.data.api;

import com.ptvgroup.developer.client.data.ApiClient;
import com.ptvgroup.developer.client.data.ApiException;
import com.ptvgroup.developer.client.data.ApiResponse;
import com.ptvgroup.developer.client.data.Pair;

import com.ptvgroup.developer.client.data.model.CustomRoadAttributeScenario;
import com.ptvgroup.developer.client.data.model.CustomRoadAttributeScenarioList;
import com.ptvgroup.developer.client.data.model.ErrorResponse;
import com.ptvgroup.developer.client.data.model.PolylineFormat;
import com.ptvgroup.developer.client.data.model.PolylineMapType;
import com.ptvgroup.developer.client.data.model.RoadAttributesResults;
import com.ptvgroup.developer.client.data.model.RoadsResponse;
import java.util.UUID;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-29T11:47:47.660663945Z[Etc/UTC]", comments = "Generator version: 7.8.0")
public class CustomRoadAttributesApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public CustomRoadAttributesApi() {
    this(new ApiClient());
  }

  public CustomRoadAttributesApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * 
   * Create a custom road attribute scenario.
   * @param customRoadAttributeScenario The roads to be attributed. (required)
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @param polylineMapType Defines whether polylines should match the Raster Maps API or the Vector Maps API.  This parameter affects the polylines returned in the response of this request and all subsequent requests referring to this scenario, if polylines are to be returned. Once created or updated, it is not possible to request the polyline for this scenario matching a different map. (optional, default to RASTER)
   * @return CustomRoadAttributeScenario
   * @throws ApiException if fails to make API call
   */
  public CustomRoadAttributeScenario createCustomRoadAttributeScenario(CustomRoadAttributeScenario customRoadAttributeScenario, List<RoadAttributesResults> results, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    ApiResponse<CustomRoadAttributeScenario> localVarResponse = createCustomRoadAttributeScenarioWithHttpInfo(customRoadAttributeScenario, results, polylineFormat, polylineMapType);
    return localVarResponse.getData();
  }

  /**
   * 
   * Create a custom road attribute scenario.
   * @param customRoadAttributeScenario The roads to be attributed. (required)
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @param polylineMapType Defines whether polylines should match the Raster Maps API or the Vector Maps API.  This parameter affects the polylines returned in the response of this request and all subsequent requests referring to this scenario, if polylines are to be returned. Once created or updated, it is not possible to request the polyline for this scenario matching a different map. (optional, default to RASTER)
   * @return ApiResponse&lt;CustomRoadAttributeScenario&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CustomRoadAttributeScenario> createCustomRoadAttributeScenarioWithHttpInfo(CustomRoadAttributeScenario customRoadAttributeScenario, List<RoadAttributesResults> results, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createCustomRoadAttributeScenarioRequestBuilder(customRoadAttributeScenario, results, polylineFormat, polylineMapType);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createCustomRoadAttributeScenario", localVarResponse);
        }
        return new ApiResponse<CustomRoadAttributeScenario>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CustomRoadAttributeScenario>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createCustomRoadAttributeScenarioRequestBuilder(CustomRoadAttributeScenario customRoadAttributeScenario, List<RoadAttributesResults> results, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    // verify the required parameter 'customRoadAttributeScenario' is set
    if (customRoadAttributeScenario == null) {
      throw new ApiException(400, "Missing the required parameter 'customRoadAttributeScenario' when calling createCustomRoadAttributeScenario");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/road-attributes";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "results";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "results", results));
    localVarQueryParameterBaseName = "polylineFormat";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineFormat", polylineFormat));
    localVarQueryParameterBaseName = "polylineMapType";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineMapType", polylineMapType));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(customRoadAttributeScenario);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * Delete a custom road attribute scenario.
   * @param scenarioId The ID of the custom road attribute scenario. (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteCustomRoadAttributeScenario(UUID scenarioId) throws ApiException {
    deleteCustomRoadAttributeScenarioWithHttpInfo(scenarioId);
  }

  /**
   * 
   * Delete a custom road attribute scenario.
   * @param scenarioId The ID of the custom road attribute scenario. (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> deleteCustomRoadAttributeScenarioWithHttpInfo(UUID scenarioId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = deleteCustomRoadAttributeScenarioRequestBuilder(scenarioId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("deleteCustomRoadAttributeScenario", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder deleteCustomRoadAttributeScenarioRequestBuilder(UUID scenarioId) throws ApiException {
    // verify the required parameter 'scenarioId' is set
    if (scenarioId == null) {
      throw new ApiException(400, "Missing the required parameter 'scenarioId' when calling deleteCustomRoadAttributeScenario");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/road-attributes/{scenarioId}"
        .replace("{scenarioId}", ApiClient.urlEncode(scenarioId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * Get a list of all custom road attribute scenarios of the current user.
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @return CustomRoadAttributeScenarioList
   * @throws ApiException if fails to make API call
   */
  public CustomRoadAttributeScenarioList getAllCustomRoadAttributeScenarios(List<RoadAttributesResults> results, PolylineFormat polylineFormat) throws ApiException {
    ApiResponse<CustomRoadAttributeScenarioList> localVarResponse = getAllCustomRoadAttributeScenariosWithHttpInfo(results, polylineFormat);
    return localVarResponse.getData();
  }

  /**
   * 
   * Get a list of all custom road attribute scenarios of the current user.
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @return ApiResponse&lt;CustomRoadAttributeScenarioList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CustomRoadAttributeScenarioList> getAllCustomRoadAttributeScenariosWithHttpInfo(List<RoadAttributesResults> results, PolylineFormat polylineFormat) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getAllCustomRoadAttributeScenariosRequestBuilder(results, polylineFormat);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getAllCustomRoadAttributeScenarios", localVarResponse);
        }
        return new ApiResponse<CustomRoadAttributeScenarioList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CustomRoadAttributeScenarioList>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getAllCustomRoadAttributeScenariosRequestBuilder(List<RoadAttributesResults> results, PolylineFormat polylineFormat) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/road-attributes";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "results";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "results", results));
    localVarQueryParameterBaseName = "polylineFormat";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineFormat", polylineFormat));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * Get a custom road attribute scenario by its ID.
   * @param scenarioId The ID of the custom road attribute scenario. (required)
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @return CustomRoadAttributeScenario
   * @throws ApiException if fails to make API call
   */
  public CustomRoadAttributeScenario getCustomRoadAttributeScenario(UUID scenarioId, List<RoadAttributesResults> results, PolylineFormat polylineFormat) throws ApiException {
    ApiResponse<CustomRoadAttributeScenario> localVarResponse = getCustomRoadAttributeScenarioWithHttpInfo(scenarioId, results, polylineFormat);
    return localVarResponse.getData();
  }

  /**
   * 
   * Get a custom road attribute scenario by its ID.
   * @param scenarioId The ID of the custom road attribute scenario. (required)
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @return ApiResponse&lt;CustomRoadAttributeScenario&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CustomRoadAttributeScenario> getCustomRoadAttributeScenarioWithHttpInfo(UUID scenarioId, List<RoadAttributesResults> results, PolylineFormat polylineFormat) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getCustomRoadAttributeScenarioRequestBuilder(scenarioId, results, polylineFormat);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getCustomRoadAttributeScenario", localVarResponse);
        }
        return new ApiResponse<CustomRoadAttributeScenario>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CustomRoadAttributeScenario>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getCustomRoadAttributeScenarioRequestBuilder(UUID scenarioId, List<RoadAttributesResults> results, PolylineFormat polylineFormat) throws ApiException {
    // verify the required parameter 'scenarioId' is set
    if (scenarioId == null) {
      throw new ApiException(400, "Missing the required parameter 'scenarioId' when calling getCustomRoadAttributeScenario");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/road-attributes/{scenarioId}"
        .replace("{scenarioId}", ApiClient.urlEncode(scenarioId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "results";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "results", results));
    localVarQueryParameterBaseName = "polylineFormat";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineFormat", polylineFormat));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * Get roads from (click) points on a map.
   * @param points A point, a polyline or a polygon to select roads. Combined transports will not be selected.  * For a single point the road(s) closest to this point will be returned.  Usually, a single road will be returned, but if there are multiple roads at the same distance from the point, all of them will be returned. This is most likely to happen on road crossings. * Several points where the first and last point are different will be considered a polyline and  all roads intersected by this polyline will be returned. * If the polyline is closed, i.e. the first and the last point are the same, the polyline defines  a polygon and all roads whose complete polyline is within the polygon will be returned. A polygon must be  valid according to [OGC](https://www.ogc.org/standard/sfa/). Holes within polygons are not supported.  Format: &#x60;&lt;point1_lat&gt;,&lt;point1_lon&gt;,...,&lt;pointN_lat&gt;,&lt;pointN_lon&gt;&#x60;.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline defining an invalid polygon according to OGC, * contains invalid coordinates or * covers more than 5000 roads. (required)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @param polylineMapType Defines whether polylines should match the Raster Maps API or the Vector Maps API.  The polylines are used for the selection, hence the selected roads can differ when using different values. (optional, default to RASTER)
   * @return RoadsResponse
   * @throws ApiException if fails to make API call
   */
  public RoadsResponse getRoads(String points, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    ApiResponse<RoadsResponse> localVarResponse = getRoadsWithHttpInfo(points, polylineFormat, polylineMapType);
    return localVarResponse.getData();
  }

  /**
   * 
   * Get roads from (click) points on a map.
   * @param points A point, a polyline or a polygon to select roads. Combined transports will not be selected.  * For a single point the road(s) closest to this point will be returned.  Usually, a single road will be returned, but if there are multiple roads at the same distance from the point, all of them will be returned. This is most likely to happen on road crossings. * Several points where the first and last point are different will be considered a polyline and  all roads intersected by this polyline will be returned. * If the polyline is closed, i.e. the first and the last point are the same, the polyline defines  a polygon and all roads whose complete polyline is within the polygon will be returned. A polygon must be  valid according to [OGC](https://www.ogc.org/standard/sfa/). Holes within polygons are not supported.  Format: &#x60;&lt;point1_lat&gt;,&lt;point1_lon&gt;,...,&lt;pointN_lat&gt;,&lt;pointN_lon&gt;&#x60;.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline defining an invalid polygon according to OGC, * contains invalid coordinates or * covers more than 5000 roads. (required)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @param polylineMapType Defines whether polylines should match the Raster Maps API or the Vector Maps API.  The polylines are used for the selection, hence the selected roads can differ when using different values. (optional, default to RASTER)
   * @return ApiResponse&lt;RoadsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RoadsResponse> getRoadsWithHttpInfo(String points, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getRoadsRequestBuilder(points, polylineFormat, polylineMapType);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getRoads", localVarResponse);
        }
        return new ApiResponse<RoadsResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RoadsResponse>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getRoadsRequestBuilder(String points, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    // verify the required parameter 'points' is set
    if (points == null) {
      throw new ApiException(400, "Missing the required parameter 'points' when calling getRoads");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/roads";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "points";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("points", points));
    localVarQueryParameterBaseName = "polylineFormat";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineFormat", polylineFormat));
    localVarQueryParameterBaseName = "polylineMapType";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineMapType", polylineMapType));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * Perform a full update of an existing custom road attribute scenario.
   * @param scenarioId The ID of the custom road attribute scenario. (required)
   * @param customRoadAttributeScenario The custom road attribute scenario to be updated. (required)
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @param polylineMapType Defines whether polylines should match the Raster Maps API or the Vector Maps API.  This parameter affects the polylines returned in the response of this request and all subsequent requests referring to this scenario, if polylines are to be returned. Once created or updated, it is not possible to request the polyline for this scenario matching a different map. (optional, default to RASTER)
   * @return CustomRoadAttributeScenario
   * @throws ApiException if fails to make API call
   */
  public CustomRoadAttributeScenario updateCustomRoadAttributeScenario(UUID scenarioId, CustomRoadAttributeScenario customRoadAttributeScenario, List<RoadAttributesResults> results, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    ApiResponse<CustomRoadAttributeScenario> localVarResponse = updateCustomRoadAttributeScenarioWithHttpInfo(scenarioId, customRoadAttributeScenario, results, polylineFormat, polylineMapType);
    return localVarResponse.getData();
  }

  /**
   * 
   * Perform a full update of an existing custom road attribute scenario.
   * @param scenarioId The ID of the custom road attribute scenario. (required)
   * @param customRoadAttributeScenario The custom road attribute scenario to be updated. (required)
   * @param results Defines which results will be returned. (optional)
   * @param polylineFormat  (optional, default to GEO_JSON)
   * @param polylineMapType Defines whether polylines should match the Raster Maps API or the Vector Maps API.  This parameter affects the polylines returned in the response of this request and all subsequent requests referring to this scenario, if polylines are to be returned. Once created or updated, it is not possible to request the polyline for this scenario matching a different map. (optional, default to RASTER)
   * @return ApiResponse&lt;CustomRoadAttributeScenario&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CustomRoadAttributeScenario> updateCustomRoadAttributeScenarioWithHttpInfo(UUID scenarioId, CustomRoadAttributeScenario customRoadAttributeScenario, List<RoadAttributesResults> results, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateCustomRoadAttributeScenarioRequestBuilder(scenarioId, customRoadAttributeScenario, results, polylineFormat, polylineMapType);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateCustomRoadAttributeScenario", localVarResponse);
        }
        return new ApiResponse<CustomRoadAttributeScenario>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CustomRoadAttributeScenario>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateCustomRoadAttributeScenarioRequestBuilder(UUID scenarioId, CustomRoadAttributeScenario customRoadAttributeScenario, List<RoadAttributesResults> results, PolylineFormat polylineFormat, PolylineMapType polylineMapType) throws ApiException {
    // verify the required parameter 'scenarioId' is set
    if (scenarioId == null) {
      throw new ApiException(400, "Missing the required parameter 'scenarioId' when calling updateCustomRoadAttributeScenario");
    }
    // verify the required parameter 'customRoadAttributeScenario' is set
    if (customRoadAttributeScenario == null) {
      throw new ApiException(400, "Missing the required parameter 'customRoadAttributeScenario' when calling updateCustomRoadAttributeScenario");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/road-attributes/{scenarioId}"
        .replace("{scenarioId}", ApiClient.urlEncode(scenarioId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "results";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "results", results));
    localVarQueryParameterBaseName = "polylineFormat";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineFormat", polylineFormat));
    localVarQueryParameterBaseName = "polylineMapType";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("polylineMapType", polylineMapType));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(customRoadAttributeScenario);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
