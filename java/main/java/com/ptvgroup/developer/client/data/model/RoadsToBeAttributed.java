/*
 * Data
 * With the Data service you can obtain additional data such as vehicle profiles.
 *
 * The version of the OpenAPI document: 1.17
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.data.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.data.model.RoadAttributes;
import com.ptvgroup.developer.client.data.model.RoadDirectionType;
import com.ptvgroup.developer.client.data.model.Validity;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.ptvgroup.developer.client.data.ApiClient;
/**
 * RoadsToBeAttributed
 */
@JsonPropertyOrder({
  RoadsToBeAttributed.JSON_PROPERTY_POINTS,
  RoadsToBeAttributed.JSON_PROPERTY_POLYLINES,
  RoadsToBeAttributed.JSON_PROPERTY_DIRECTION,
  RoadsToBeAttributed.JSON_PROPERTY_ATTRIBUTES,
  RoadsToBeAttributed.JSON_PROPERTY_VALIDITY,
  RoadsToBeAttributed.JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE,
  RoadsToBeAttributed.JSON_PROPERTY_DESCRIPTION
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-29T11:47:47.660663945Z[Etc/UTC]", comments = "Generator version: 7.8.0")
public class RoadsToBeAttributed {
  public static final String JSON_PROPERTY_POINTS = "points";
  private String points;

  public static final String JSON_PROPERTY_POLYLINES = "polylines";
  private List<String> polylines = new ArrayList<>();

  public static final String JSON_PROPERTY_DIRECTION = "direction";
  private RoadDirectionType direction = RoadDirectionType.BOTH;

  public static final String JSON_PROPERTY_ATTRIBUTES = "attributes";
  private RoadAttributes attributes;

  public static final String JSON_PROPERTY_VALIDITY = "validity";
  private Validity validity;

  public static final String JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE = "unmatchedAfterMapUpdate";
  private Boolean unmatchedAfterMapUpdate = false;

  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  private String description;

  public RoadsToBeAttributed() { 
  }

  public RoadsToBeAttributed points(String points) {
    this.points = points;
    return this;
  }

  /**
   * A point, a polyline or a polygon to select roads. Combined transports will not be selected.  * For a single point the road(s) closest to this point will be returned.  Usually, a single road will be returned, but if there are multiple roads at the same distance from the point, all of them will be returned. This is most likely to happen on road crossings. * Several points where the first and last point are different will be considered a polyline and  all roads intersected by this polyline will be returned. * If the polyline is closed, i.e. the first and the last point are the same, the polyline defines  a polygon and all roads whose complete polyline is within the polygon will be returned. A polygon must be  valid according to [OGC](https://www.ogc.org/standard/sfa/). Holes within polygons are not supported.  Format: &#x60;&lt;point1_lat&gt;,&lt;point1_lon&gt;,...,&lt;pointN_lat&gt;,&lt;pointN_lon&gt;&#x60;.  A request will be rejected if it * does not contain an even number of coordinates, * contains a closed polyline defining an invalid polygon according to OGC, * contains invalid coordinates, * covers no road or * covers more than 5000 roads.
   * @return points
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_POINTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getPoints() {
    return points;
  }


  @JsonProperty(JSON_PROPERTY_POINTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPoints(String points) {
    this.points = points;
  }


  public RoadsToBeAttributed polylines(List<String> polylines) {
    this.polylines = polylines;
    return this;
  }

  public RoadsToBeAttributed addPolylinesItem(String polylinesItem) {
    if (this.polylines == null) {
      this.polylines = new ArrayList<>();
    }
    this.polylines.add(polylinesItem);
    return this;
  }

  /**
   * The polylines of the roads in the format specified by **polylineFormat**.  Only present in responses, will be ignored in requests.
   * @return polylines
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_POLYLINES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getPolylines() {
    return polylines;
  }


  @JsonProperty(JSON_PROPERTY_POLYLINES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPolylines(List<String> polylines) {
    this.polylines = polylines;
  }


  public RoadsToBeAttributed direction(RoadDirectionType direction) {
    this.direction = direction;
    return this;
  }

  /**
   * Get direction
   * @return direction
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DIRECTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public RoadDirectionType getDirection() {
    return direction;
  }


  @JsonProperty(JSON_PROPERTY_DIRECTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDirection(RoadDirectionType direction) {
    this.direction = direction;
  }


  public RoadsToBeAttributed attributes(RoadAttributes attributes) {
    this.attributes = attributes;
    return this;
  }

  /**
   * Get attributes
   * @return attributes
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public RoadAttributes getAttributes() {
    return attributes;
  }


  @JsonProperty(JSON_PROPERTY_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAttributes(RoadAttributes attributes) {
    this.attributes = attributes;
  }


  public RoadsToBeAttributed validity(Validity validity) {
    this.validity = validity;
    return this;
  }

  /**
   * Get validity
   * @return validity
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_VALIDITY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Validity getValidity() {
    return validity;
  }


  @JsonProperty(JSON_PROPERTY_VALIDITY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setValidity(Validity validity) {
    this.validity = validity;
  }


  public RoadsToBeAttributed unmatchedAfterMapUpdate(Boolean unmatchedAfterMapUpdate) {
    this.unmatchedAfterMapUpdate = unmatchedAfterMapUpdate;
    return this;
  }

  /**
   * If **roadsToBeAttributed** or **combinedTransportsToBeAttributed** could not be matched to a new map after an update they are marked with this boolean flag. Unmatched **roadsToBeAttributed** or **combinedTransportsToBeAttributed** might cause some unwanted changes of behavior for the scenario. This parameter must not be true if it is sent as part of a request.
   * @return unmatchedAfterMapUpdate
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getUnmatchedAfterMapUpdate() {
    return unmatchedAfterMapUpdate;
  }


  @JsonProperty(JSON_PROPERTY_UNMATCHED_AFTER_MAP_UPDATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUnmatchedAfterMapUpdate(Boolean unmatchedAfterMapUpdate) {
    this.unmatchedAfterMapUpdate = unmatchedAfterMapUpdate;
  }


  public RoadsToBeAttributed description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A description of this set of attributed roads which is useful to refer to that in an application.
   * @return description
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getDescription() {
    return description;
  }


  @JsonProperty(JSON_PROPERTY_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDescription(String description) {
    this.description = description;
  }


  /**
   * Return true if this RoadsToBeAttributed object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RoadsToBeAttributed roadsToBeAttributed = (RoadsToBeAttributed) o;
    return Objects.equals(this.points, roadsToBeAttributed.points) &&
        Objects.equals(this.polylines, roadsToBeAttributed.polylines) &&
        Objects.equals(this.direction, roadsToBeAttributed.direction) &&
        Objects.equals(this.attributes, roadsToBeAttributed.attributes) &&
        Objects.equals(this.validity, roadsToBeAttributed.validity) &&
        Objects.equals(this.unmatchedAfterMapUpdate, roadsToBeAttributed.unmatchedAfterMapUpdate) &&
        Objects.equals(this.description, roadsToBeAttributed.description);
  }

  @Override
  public int hashCode() {
    return Objects.hash(points, polylines, direction, attributes, validity, unmatchedAfterMapUpdate, description);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RoadsToBeAttributed {\n");
    sb.append("    points: ").append(toIndentedString(points)).append("\n");
    sb.append("    polylines: ").append(toIndentedString(polylines)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    validity: ").append(toIndentedString(validity)).append("\n");
    sb.append("    unmatchedAfterMapUpdate: ").append(toIndentedString(unmatchedAfterMapUpdate)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `points` to the URL query string
    if (getPoints() != null) {
      joiner.add(String.format("%spoints%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getPoints()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `polylines` to the URL query string
    if (getPolylines() != null) {
      for (int i = 0; i < getPolylines().size(); i++) {
        joiner.add(String.format("%spolylines%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix),
            URLEncoder.encode(ApiClient.valueToString(getPolylines().get(i)), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
      }
    }

    // add `direction` to the URL query string
    if (getDirection() != null) {
      joiner.add(String.format("%sdirection%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getDirection()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `attributes` to the URL query string
    if (getAttributes() != null) {
      joiner.add(getAttributes().toUrlQueryString(prefix + "attributes" + suffix));
    }

    // add `validity` to the URL query string
    if (getValidity() != null) {
      joiner.add(getValidity().toUrlQueryString(prefix + "validity" + suffix));
    }

    // add `unmatchedAfterMapUpdate` to the URL query string
    if (getUnmatchedAfterMapUpdate() != null) {
      joiner.add(String.format("%sunmatchedAfterMapUpdate%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getUnmatchedAfterMapUpdate()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `description` to the URL query string
    if (getDescription() != null) {
      joiner.add(String.format("%sdescription%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getDescription()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    return joiner.toString();
  }
}

